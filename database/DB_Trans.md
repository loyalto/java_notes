## 什么是数据库事务，MySQL 为什么会使用 InnoDB 作为默认选项
- 事务：事务是数据库管理系统执行过程中的一个逻辑单元，由一个有限的数据库操作序列构成。
- 为什么InnoDB是默认选项：InnoDB支持事务、InnoDB支持行锁、InnoDB存储索引方式减少IO

## 简述数据库中的 ACID 分别是什么？
- A（原子性，Atomicity）：数据库操作序列，要么都成功，要么都失败
  
  - 通过undo log实现，记录了更新、删除、插入修改对应的操作，可以还原数据
  
- C（一致性，Consistent）：数据库的完整性约束没有被破快，事务执行前后都是合法的数据状态（像唯一性，字段长度校验，类型符合，转账增钱减钱符合预期等）
  
  - 原子性、隔离性、持久性一起保证一致性
  
- I（隔离性，Isolation）：多个事务并发对数据操作，应该是隔离的，互不干扰的
  
  - 通过mvcc（multi version concurrency control多版本并发控制）对于select，LBCC（lock based concurrency control基于锁的并发控制）对于update、insert、delete
  
- D（持久性，Durability）：对数据库的操作，增、删、改只要事务提交了，就是永久的，即落库
  
  - 通过redo log（写redo log是因为redo log是append操作，顺序io，数据库数据存储磁盘可能不一样，碎片化）实现，因为数据库是先把数据写入缓冲池，而不是直接写入磁盘（基于性能考虑，提高读写效率），所以当突然断电或磊机时，需要从redo log恢复数据
  
### 隔离级别的解决方式
####   MVCC（multi version concurrency control多版本并发控制）
`MVCC`解决的是读-写场景下的并发控制，常规select就是使用的`MVCC`,通过数据快照版，达到同一事务读一致性。主要通过undo log、版本链、ReadView实现
- undo log：记录了所有对数据的操作
- 版本链：每行数据有一个隐藏的列db_roll_ptr，指向之前对数据的操作记录
- ReadView：记录了活跃事务ids、活跃事务ids中的最小值、生成ReadView时应该分配给下一事务的id、当前事务的id。通过这些事务id，限制了只能访问，当前事务创建前已提交事务的数据和本事务提交的数据。
#### LBCC（lock based concurrency control基于锁的并发控制）
`LBCC`是对数据索引加锁（没有索引时，锁住的是rowid），可以从三个维度去理解锁的范围、锁的类型、锁的算法。增、删、改都会对数据加锁，select加上for也会对数据加锁。
- 锁的范围：分为表锁和行锁
- 锁的类型：分为共享、排他、意向
  - 共享锁： select ...... lock in share mode ，共享锁之间不互斥，与排它锁互斥
  - 排他锁：增、删、改都是排他锁，select......for update也是排他锁
  - 意向锁：与其他锁并不冲突，用于方便判断，比如加表锁时，需要判断是否还有行锁
- 锁的算法
  - 记录锁：条件是=，命中索引时，锁住对应的行数据
  - 间隙锁：根据已有数据，分成一段一段，锁住一段数据，比如自增id 1,3,7，分为(1,3),(3,7),(7,正无穷)，根据没命中的查询数据在哪一段，锁住那一段的数据
  - 临键锁：范围查询即命中了已有数据，又有未命中的，使用临键锁，它与间隙锁不同的是数据段包含了已有数据

## 数据库的事务隔离级别有哪些？各有哪些优缺点？
数据库的事务隔离级别是针对`读一致性`来讨论的，隔离级别有四个，分别解决不同程度的问题
- Read Uncommitted（读未提交）：同一事务中两次读取，第二次读取到其他事务还未提交的sql，导致两次读取不一致
- Read Committed（已提交读）：同一事务中两次读取，第二次读取到其他已提交事务`update、delete`对第一读取数据的操作，导致两次读取不一致
- Repeatable Read（可重复读）：同一事务中两次读取，第二次读取到其他已提交事务`insert`符合读取条件的数据，导致两次读取不一致
- Serializable（串行化）：所有事务串行执行，解决所有问题
- 优缺点：随着隔离级别的上升，解决的并发读问题变多，操作变慢。

## 简述乐观锁以及悲观锁的区别以及使用场景

- 乐观锁：总是假设不会发生冲突，当更新时通过比较值判断能否更新
- 悲观锁：总是假设发生冲突，锁定数据不让访问
- 适用场景：乐观锁适合读多写少的场景，悲观锁适合写多读少的场景

## 什么情况下会发生死锁，如何解决死锁？
发生死锁的条件如下：
- 同一时刻只能有一个事务持有这把锁
- 其他事务只能在持有锁事务释放锁后才能得到锁，而不能强行剥夺
- 多个事务形成环形等待

比如有两行数据A、B，事务1锁住A，执行事务2，锁住B，事务1接着想锁住B，事务2接着想锁住A就死锁了。


死锁的解决
- 默认锁超时是50秒
- 对数据进行操作时，尽量以相同的顺序访问（避免环形等待）
- where条件尽量走索引，因为没有索引会锁住所有行，加大发生死锁概率
- 在事务中尽量一次锁住需要的资源
- 如果可以大事务化小事务，减少耗时冲突
- 尽量使用等号命中索引，避免间隙锁的影响