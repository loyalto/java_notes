## 简述数据库中什么情况下进行分库，什么情况下进行分表？
当数据库由于数据量访问量增加成为性能瓶颈（数据量变大每次查询大量IO，扫描行数变多，执行的过滤、排序、组合变多），造成响应变慢甚至无法响应时，需要分库分表。分库分表分为垂直与水平。
### 垂直
- 垂直分库：以业务为维度，将不同的表拆分到不同的库中，可以抽象出单独的业务模块
- 垂直分表：以字段为依据，将表中字段拆分到不同的表中，一般为主表和扩展表
### 水平
- 水平分库：按照一定策略（hash比如用户id，range比如日期等），将一个库的数据水平分到多个库上
- 水平分表：按照一定策略（hash比如用户id，range比如日期等），将一个库的数据水平分到多个表上
### 分库分表问题
- 非分库key作为查询条件：使用映射表（数据库表或者缓存）找到分库key；基因法，生成的分库key与查询的非分库key有关联，可以通过函数映射得到应该分到哪个库
- 跨库跨表查询问题：用NoSQL解决，专门一个后台服务做统计，牺牲一定的实时性
- 扩容问题：新加库作为从库，异步双写，当完成数据迁移后，再按新的规则走，解除主从同步。按时间增长的无需考虑扩容问题
## 如何解决主从不一致的问题？
主从复制是使用bin log传输操作语句实现，造成主从不一致一般有以下几种原因
- 设置sql_log_bin=0导致主库不记录bin log
- 从节点未设置只读，导读从节点有数据写入
- 主从版本不一致，导致同步出现问题

解决办法是检查主从的配置，不能设置主库sql_log_bin为0，从库设置只允许读取，定期检测主从同步。对于强一致性的读取，读取主库数据。
## MySQL 有哪些常见的存储引擎？它们的区别是什么？
### MyISAM
- 不支持事务，表级别锁定
- 较高的插入、查询速度
- 三个文件表结构、索引、数据

适合只读或者读多的场景
### InnoDB
- 支持事务，行锁
- 支持读写并发，不阻塞读（MVCC）
- 两个文件表结构、索引与数据

适合经常更新，并发多的场景

### memory

- 存储在内存中，适合临时表

## MySQL 中 varchar 和 char 的区别是什么？
- char是定长的，varchar是变化的会有一个字节用于记录长度
- 对于固定长度的字段使用char，节约记录长度的那一个字节

## SQL优化的方案有哪些，如何定位问题并解决问题？
### 定位问题
- 记录慢sql，可以通过设置show_query_log记录下慢sql，mysqldumpshow可以展示出最慢的sql
- show full processlist 可以显示用户运行线程状态
- 可以开启锁监控
- 用explain查看sql执行情况，找出具体慢的原因
  - **id**：执行顺序，id越大的越先执行，id相同从上往下
  - select type：查询类型，简单查询（没有子查询这些）、主查询（有联合查询中的主查询）、子查询（有联合查询中的子查询）等
  - **type**：连接类型，常见的有system、const（主键或者唯一索引，只有一条数据符合）、eq_ref（联合查询时通过唯一索引查询）、ref（普通索引）、range（索引范围扫描）、index（查询全部索引中的数据）、all（全表扫描）等
  - possible_key：可能用到的索引
  - **key**：实际用到的索引
  - key_len：索引的长度
  - **rows**：预估扫描多少行才能返回数据
  - filtered：返回的数据占据存储引擎查询出来数据的比例
  - ref：使用哪个列和索引一起从表中筛选数据
  - extra：额外给出的信息说明，比如使用了覆盖索引、使用了where、使用了索引条件下推等
### 解决问题
- 创建索引或者联合索引
- 使用小表驱动大表
- 用join代替子查询

## 性能优化总结
- sql与索引：为查询建立合适索引、小表驱动大表、减少子查询等
- 存储引擎和表结构：选择适合的存储引擎，表字段尽量小的类型，非空字段尽量定义成not null，不使用外键、触发器、视图这些，不存储文件流
- 架构层面：使用缓存、读写分离、分库分表
- 业务优化：限流、查询不支持跨月等
