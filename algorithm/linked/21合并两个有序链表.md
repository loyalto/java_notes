## 解法一
### 思路
递归，每次拿取链表中较小节点，回溯时再一一拼接上去
1. 初始：传入两个链表
2. 中间递归：选取小的节点，等待回溯时把后续节点拼接上去
3. 结束条件：其中一个为空

举例如下
```java
链表1:1->3
链表2:2
1. 取到1，等待把3与2结果拼接到1的next
2. 取到2，等待把3与null结果拼接到2的next
3. 有一个为空，返回3
4. 3拼接到2后面 ， 返回2->3
5. 2->3拼接到1后面，返回1->2->3
```

### 时空复杂度
- 时间复杂度：链表1长度S，链表2长度N，O（S+N）
- 空间复杂度：O（S+N）

## 解法二
### 思路
迭代，设置一个前置节点head，用prev 记录迭代到哪里了，当其中一个链表为空时，将其拼接到prev后面即可，举例如下
```java
链表1:1->3
链表2:2
初始：prev、head
1. head->1
        prev
2. head->1->2
        prev
3. head->1->2
           prev
4. 链表2为空，将链表1剩余部分拼接到prev后面           
```

### 时空复杂度
- 时间复杂度：链表1长度S，链表2长度N，O（S+N）
- 空间复杂度：O（1）




