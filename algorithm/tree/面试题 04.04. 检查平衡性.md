## 方式一
### 思路
自顶向下，获取当前节点的左右子节点高度，比较是否平衡。然后DFS方式递归查看所有节点是否平衡，举例如下
```java
  7
 3 7
2 4
   4
定义高度函数
1. 为空返回0
2. 否则返回左右子节点高度较大的那个+1

平衡函数
1. 为空返回true
2. 获取左右子节点的高度
3. 比较左右子节点的高度是否相差1以内，并且左右子节点也是平衡的

以上面这颗树为例，获取左子节点高度为3，右子节点高度为1，相差2返回false
```

### 时空复杂度
- 时间复杂度：O（n^2），遍历所有节点n，求节点高度n
- 空间复杂度：O（n），最坏情况高度为n，递归n

## 方式二
### 思路
自底向上，自顶向下每个节点都在计算高度，存在重复子问题，自底向上，每个节点返回当前高度，当不平衡时返回-1，举例如下
```java
  7
 3 7
2 4
   4
定义获取高度的递归函数
1. 为null返回0
2. 获取左子节点高度，获取右子节点高度
3. 如果左子节点为-1或者右子节点为-1或者左右子节点相差大于1，说明当前节点是不平衡的，返回-1，否者返回左右子节点较大高度+1

以上面这棵树为例，、
1. 当递归到3时，左节点获取到的高度为1，右节点获取到的高度为2,3的高度为3
2. 根节点7的右节点高度为1，左右相差2，返回-1
```

### 时空复杂度
- 时间复杂度：O（n），遍历所有节点n
- 空间复杂度：O（n），最坏情况高度为n，递归n
