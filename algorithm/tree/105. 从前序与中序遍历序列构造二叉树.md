## 思路
递归
1. 通过前序遍历找到中节点，在中序遍历找到位置（找位置可以用map记录数与位置对应关系）
2. 中序遍历的前后半截分别为左右子树，通过中序遍历这两截**长度**可以在前序遍历中找到中节点的左右子节点，递归这个过程
3. 结束条件为左右长度小于1

举例如下
```java
    1
  2   3
4  5 
前序：1 2 4 5 3
中序：4 2 5 1 3

1. 第一轮索引位置
前序：1 2 4 5 3
     s       e
中序：4 2 5 1 3
    ms       me
中节点1，在中序中找到位置3,左子树长度为3，右子树长度为1

2. 先找左边，第二轮索引位置 sl=s+1,el =s+左子树长度，msl=ms，mel=中序找到位置减1
前序：1 2 4 5 3
      sl   el
中序：4 2 5 1 3
    msl mel
中节点2，在中序位置1， 左右分别为1

3. 先找左边，第三轮索引位置 sl=s+1,el =s+左子树长度，msl=ms，mel=中序找到位置减1
前序：1 2 4 5 3
        sl
        el
中序：4 2 5 1 3
    msl 
    mel
中节点4，左右分别为0，下次递归开始长度大于结束长度，左右节点返回null，组成第一个下部节点返回
右边一样构成节点返回只是右边
  前序：开始位置=前序中节点位置+中序中左长度+1 结束位置=上次递归结束位置
  中序：开始位置=中序找到位置+1 结束位置=上次递归结束位置
4. 递归将构建好的节点赋值给上一层的左右子节点返回即可
```
## 时空复杂度
- 时间复杂度：O（n），构建辅助空间n，递归n
- 空间复杂度：O（n），辅助空间n，递归n