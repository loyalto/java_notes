## 解法一
### 思路
暴力解法，遍历每个节点深度递归查找是否有pq，两次递归
### 时空复杂度
- 时间复杂度：O（n^2）
- 空间复杂度：O（n）

## 解法二
### 思路
借助hashmap辅助查找
1. 递归用map记录所有节点的父节点
2. 用set记录p到根节点所有节点
3. 从q节点向上查找在p的路径中第一个相同节点即为最近公共祖先
### 时空复杂度
- 时间复杂度：O（n）
- 空间复杂度：O（n）

## 解法三
### 思路
从下自上返回是否查找到，pq节点有以下几种分布方式
```java
1.  x（pq都为同一个节点）
2.  x （pq分别在一个节点的两边）
   p q
3. p （pq其中一个节点在上面）
  q

根据上诉情形，建立以下递归
1. 分别递归左右查找pq
2. 如果找到pq任一返回
3. 边界为null的时候
4. 如果左右查找到，为情形二，返回当前节点；如果左右任一为空，为情形三，返回左右不为空的那一个；情形三返回结果包含了情形一
```
### 时空复杂度
- 时间复杂度：O（n）
- 空间复杂度：O（n）
