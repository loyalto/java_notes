## 解法一
### 思路
合并两个数组，求取中位数
### 时空复杂度
数组长度分别为m与n
- 时间复杂度：O（m+n）
- 空间复杂度：O（m+n）
## 解法二
### 思路
双指针迭代
### 时空复杂度
数组长度分别为m与n
- 时间复杂度：O（m+n）
- 空间复杂度：O（1）
## 解法三
### 思路
二分淘汰，数组长度分别为m与n，奇数的中位数为第（m+n）/2；偶数的中位数为（第（（m+n）/2 ）+1 ）+（第（（m+n）/2 ）-1 ）除以2。可以转换为求第多少个数的值。而当求第k个数的值时，因为是有序数组可以二分查找，举例如下
```java
nums1 1 3 5
     s1
nums2 1 2 5 7 8 10
     s2
k = 9/2 = 4
- 每次s1与s2向后移动（k/2）-1（当前位置占了一个数）的距离，当位置加上（k/2）-1大于等于数组长度时，等于数组长度-1（从位置0开始），新的位置为newS1、newS2
- 比较newS1与newS2位置的值大小，抛弃较小的位置前的数（包含较小位置）,通过newS1、newS2、s1、s2能计算出抛弃了多少个数，还要往后面多少个数
- 继续下一次迭代，下一次迭代结束条件有两个
  - k=1，第一个数，直接比较s1与s2位置谁更小就可以
  - s1或者s2等于数组长度，说明有一个数组完全被淘汰了，直接用剩下的数组找剩下的第k个值
上面列子第二轮
nums1 1 3 5
        s1
nums2 1 2 4 7 8 10
          s2
k = 9/2 = 4-2 =2
上面列子第三轮
nums1 1 3 5
          s1
nums2 1 2 4 7 8 10
          s2
k = 9/2 = 4-2 =2 - 1 = 1
达到结束循环条件，返还s1与s2较小位置的数
```

### 时空复杂度

- 时间复杂度：O（log（m+n））
- 空间复杂度：O（1）
