- 原子类Atomic：CAS、volatile
- 锁
	1. AQS：state、双向链表、owner、模板方法、CAS、LockSupport
	2. Condition：双向链表、CAS、LockSupport、有响应中断的await和不响应中断的await
	3. 自带锁实现
		3.1 可重入锁：排他锁
		3.2 读写锁：同一个sync、高16位读（共享状态），低16位写（独占状态）
		3.3 StampedLock：读写锁优化性能（读写并发，多个读与一个写同时）、乐观锁、工具内部使用、不可重入、stamp判断是否需要独占
	4. 总结：核心是AQS，LockSupport阻塞唤醒线程，CAS和volatile临界区判断，等待队列为链表
- 线程安全工具
	1. 阻塞队列
		1.1 接口：BlockingDeque（双端队列接口）、BlockingQueue（获取不到时阻塞，添加不了阻塞）、TransferQueue（转移，阻塞直到被消费）
		1.2 ArrayBlockingQueue：数组、一个锁、两个Condition
		1.3 LinkedBlockingQueue：链表、两个锁、两个Condition
		1.4 PriorityBlockingQueue：堆、一个锁、一个Condition、无界
		1.5 SynchronousQueue：队列或栈、CAS、transfer接口（根据传入数据是否为空判断存还是取）
		1.6 总结：阻塞队列核心是BlockingQueue，双端队列与转移是功能的扩展；BlockingQueue不同的实现根据数据结构做调整，比如数组结构比较轻快，相比链表没有多余数据（指针）产生消除，所以只有一个锁；而堆因为是无界的所以只有一个Condition，同时因为总是存取的第一个元素，所以只有一个锁。
	2. 安全集合
		2.1 map：ConcurrentHashMap、ConcurrentSkipListMap
		2.2 set: ConcurrentSkipListSet、CopyOnWriteArraySet
		2.3 queue：ConcurrentLinkedDeque、ConcurrentLinkedQueue、CopyOnWriteArrayList
	3. 常用工具
		3.1 CountDownLatch：一个等待多个线程、AQS
		3.2 CyclicBarrier：多个一起等待、循环使用、可重入锁
		3.3 Semaphore：AQS
- 线程
	1. 接口
		1.1 Callable：带返回结果的异步接口
		1.2 Future：操作异步线程的接口，通常与Callable结合使用；与Runable结合使用时get的返回结果是死的，感觉只是为了统一操作
		1.3 FutureTask：线程池的默认Future，Runable、Callable、Future的结合，因为Thread的入参接口是Runable，只要Thread才真正与操作系统内核线程对应（1:1模型），实现Runable与Future，Callable作为参数在run方法中调用
	2. 线程池
		2.1 Runable进入线程池的三个出路：直接worker、任务队列、拒绝策略拒绝
		2.2 Worker：集成AQS与Runable，从队列中拿任务运行，回收是消除持有等待GC回收
		2.3 核心参数：核心线程数、最大线程数、队列
		2.4 状态：运行、shutdown（不接受新任务，阻塞队列中任务要处理）、stop（shutdownNow，不接受新任务，不处理阻塞队列任务，中断正在处理任务）、Tidying（workerCount有效线程数为0）、terminated（terminated方法执行之后）